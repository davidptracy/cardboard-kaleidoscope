using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class sphericalOps : MonoBehaviour {

	//multiplier for the radius of the sphere
	public float mult;

	// a variable to reference the Cardboard camera
	public GameObject globalCardboardObject;
	// a variable to hold the rotation from Cardboard
	private Quaternion localCardboardRotation;
	private Quaternion lastLocalCardboardRotation;
	
	// array to hold the vertices of the mesh
	private Vector3[] vertices;

	// array to hold the cubes generated by the mesh
	private List<GameObject> cubes;

	private WebCamTexture mCamera = null;

	// Use this for initialization
	void Start () {

		Mesh mesh = this.GetComponent<MeshFilter> ().mesh;
		Vector3[] vertices = mesh.vertices;

		// instantiate a new list of GameObjects
		cubes = new List<GameObject> ();

		mCamera = new WebCamTexture ();
		mult = 5.0f;

		print (vertices.Length);

//		cubes = new GameObject[vertices.Length];

		for (int i = 0; i<vertices.Length; i+=2) {
			GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
			cube.transform.position = new Vector3(vertices[i].x*mult, vertices[i].y*mult, vertices[i].z*mult);
			cube.transform.Rotate(i*15, i*15, i*15);
			cube.GetComponent<Renderer>().material.mainTexture = mCamera;
			cubes.Add (cube);
			// create a list that holds locations, use that list to check if an object is already there

		}

		//remove any cubes that are duplicated on top of each other
//		foreach (var cube in cubes) {
//			foreach (var checkCube in cubes){
//				if (cube == checkCube){
//					continue;
//				}
//				if (Vector3.Distance(cube.GetComponent<Transform>().position, checkCube.GetComponent<Transform>().position) == 0.0f){
//					cubes.Remove(checkCube);
//					print ("removed one cube");
//					break;
//				}
//			}
//			cube.GetComponent<Renderer>().material.mainTexture = mCamera;
//		}

		mCamera.Play ();
	
	}
	
	// Update is called once per frame
	void Update () {

		// grabs cardboard rotation from the global game object
		localCardboardRotation = globalCardboardObject.GetComponent<CardboardHandler>().cardboardRotation;

		//convert cardboard rotation to useable euler angles
		var angles = localCardboardRotation.eulerAngles;
		var lastAngles = lastLocalCardboardRotation.eulerAngles;
		print (angles);

//		float xRot = angles.x;
//		float yRot = angles.y;
//		float zRot = angles.z;
//		
//		float xRotPrev = lastAngles.x;
//		float yRotPrev = lastAngles.y;
//		float zRotPrev = lastAngles.z;

//		float xRot = Mathf.Clamp(angles.x, 0.0f, 10.0f);
//		float yRot = Mathf.Clamp(angles.y, 0.0f, 10.0f);
//		float zRot = Mathf.Clamp(angles.z, 0.0f, 10.0f);
//
//		float xRotPrev = Mathf.Clamp(lastAngles.x, 0.0f, 10.0f);
//		float yRotPrev = Mathf.Clamp(lastAngles.y, 0.0f, 10.0f);
//		float zRotPrev = Mathf.Clamp(lastAngles.z, 0.0f, 10.0f);

		var x = 0;

		foreach (var cube in cubes) {



			if (x % 2 == 0){
				cube.transform.Rotate (angles-lastAngles);
			} else {
				cube.transform.Rotate (angles-lastAngles);
			}

			x++;
		}

		if (x > cubes.Count) {
			x=0;
		}

		lastLocalCardboardRotation = localCardboardRotation;
	}
}