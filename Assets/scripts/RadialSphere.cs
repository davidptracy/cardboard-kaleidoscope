// C# script for a 3D kaleidoscope.
// The script places a kaleidoscope object on each vertex of a mesh and rotates in sync with a googleCardboard.
// In this case, the mesh is a procedurally generated icosahedron, see IcoSphereCreate.cs
// The script is attached to a gameObject which can be empty
// 2015 by David Tracy @ Rockwell Group Lab

using UnityEngine;
using System.Collections;
using System.Collections.Generic; //required to use Lists

public class RadialSphere : MonoBehaviour {

	public GameObject cardboardHead; //a reference to the cardboard 'head'
	public float scaleFactor; // a variable to adjust the scale of the cubes in the inspector
	public bool videoEnabled; // a toggle to control whether or not the webcam is playing

	private List<RadialKaleidoscope> kaleidoscopes; //list to hold all of the kaleidoscopes
	private GameObject sphere; //a gameobject to reference the mesh
	private WebCamTexture mCamera = null; //an empty webcam texture
	private Quaternion localCardboardRotation; //variable to hold the current rotation from Cardboard
	private Quaternion lastLocalCardboardRotation; //variable to hold the last rotation from Cardboard
	private Vector3 angles;
	private Vector3 lastAngles;
	private Vector3 origin;
	private Vector3 camHeading; //vector for rotation relative to camera
	private Vector3[] vertices; //array to hold the vertices of the mesh
	private Shader shaderRed;
	private Shader shaderBlue;
	private Shader shaderGreen;

	// Use this for initialization
	void Start () {

		// start the scene with video playing
		videoEnabled = true;
		// the origin of the scene
		origin = Vector3.zero;
		// this is a hardcoded name generated by IcoSphereCreate.cs
		sphere = GameObject.Find("Isocahedron");
		// get the mesh component of the isocahedron
		Mesh mesh = sphere.GetComponent<MeshFilter> ().mesh;
		// places all of the vertex coordinates in an array
		vertices = mesh.vertices;
		//instantiate a new list of RadialKaleidoscopes
		kaleidoscopes = new List<RadialKaleidoscope> ();
		// instantiate the webcam
		mCamera = new WebCamTexture ();
		// get the heading from the cardboard head
		camHeading = cardboardHead.transform.forward;

		scaleFactor = 0.325f;

		// find the appropriate shaders
		shaderRed = Shader.Find ("Custom/RedTint");
		shaderBlue = Shader.Find ("Custom/BlueTint");
		shaderGreen = Shader.Find ("Custom/GreenTint");

		// iterate through all the vertices to place a kaleidoscope
		for (int i = 0; i<vertices.Length; i++) {

			// a shader variable to pass to the kaleidoscope
//			Shader theShader;
//
//			if (i % 3 == 0){
//				theShader = shaderBlue;
//			} else if (i % 2 == 0){
//				theShader = shaderRed;
//			} else {
//				theShader = shaderGreen;
//			}

			// generate a new kaleidoscope at each vertex of the icosahedron
			RadialKaleidoscope kaleidoscope = new RadialKaleidoscope (1.0f, 6, 0.125f, 0.0f, vertices[i], mCamera, scaleFactor, camHeading);
//			RadialKaleidoscope kaleidoscope = new RadialKaleidoscope (1.0f, 6, 0.125f, 0.0f, vertices[i], mCamera, scaleFactor, camHeading, theShader);			
			// add the cube to the list of cubes
			kaleidoscopes.Add (kaleidoscope);			
		}
		// play the webcam texture
		mCamera.Play ();	
	}
	
	// Update is called once per frame
	void Update () {

		//update the camera heading
		camHeading = cardboardHead.transform.forward;
		
		//convert cardboard's quaternion to useable euler angles
		localCardboardRotation = this.GetComponent<CardboardHandler>().cardboardRotation;
		angles = localCardboardRotation.eulerAngles;
		lastAngles = lastLocalCardboardRotation.eulerAngles;

		// iterate through all the cubes and rotate them based on head rotation from cardboard
		foreach (var scope in kaleidoscopes) {
			scope.update (camHeading, angles, lastAngles, scaleFactor);
			scope.display (origin);		
		}

		lastLocalCardboardRotation = localCardboardRotation;

		if (!videoEnabled && mCamera.isPlaying) {
			mCamera.Pause ();
		} else if (videoEnabled && !mCamera.isPlaying) {
			mCamera.Play ();
		}
	
	}

	private class RadialKaleidoscope {
		
		private Vector3 camHead; 
		private Vector3 bPoint; //basepoint for the circle origin
		private Vector3 angle;
		private Vector3 lastAngle;
		private int cubeCount; //the amount of cubes for the radial array
		private float radius; //the radius at which to place the cubes
		private float rotation; //the global rotation of the circle
		private float offset; //distance at which to orient the center of the circle
		private GameObject circle; //a parent gameObject to nest the cubes under, used for transformations
		private List<GameObject> cubes; //array to hold the cubes generated by the mesh
		private Shader shader;
		
		//constructor
//		public RadialKaleidoscope(float off, int cuCt, float r, float rot, Vector3 bPt, WebCamTexture mCam, float scl, Vector3 cHd, Shader shdr){
		public RadialKaleidoscope(float off, int cuCt, float r, float rot, Vector3 bPt, WebCamTexture mCam, float scl, Vector3 cHd){
			
			offset = off;
			cubeCount = cuCt;
			radius = r;
			rotation = rot;			
			bPoint = bPt;
//			shader = shdr;
			
			circle = new GameObject();
			circle.transform.position = cHd*radius;
			
			//a list to hold all the cubes
			cubes = new List<GameObject> ();

			//create the cubes
			for (int i=0; i < cubeCount; i++) {
				//generate a cube
				GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
				//move the cube to the basepoint
				cube.transform.position = cHd*radius;
				//scale the cubes
				cube.transform.localScale *= scl;
				//orient the cube toward the camera
				cube.transform.LookAt(Vector3.zero);
				//move that cube to the side
				cube.transform.position += cube.transform.right*radius;
				//rotate the cubes around the basePoint
				cube.transform.RotateAround(cHd*radius, cHd*radius - new Vector3(0.0f, 0.0f, 0.0f), i*360/cubeCount);
				//parent the cube to the empty circle object
				cube.transform.parent = circle.transform;
				//set the webcamTexture as the mainTexture for the cube
				cube.GetComponent<Renderer>().material.mainTexture = mCam;
				// instantiate a renderer
//				Renderer rend;
//				rend = cube.GetComponent<Renderer>();				
//				rend.material.shader = shader;

				//add the cube to the list
				cubes.Add(cube);
			}

			circle.transform.position = bPoint;
			circle.transform.LookAt (Vector3.zero);
			
		}
		
		public void update(Vector3 cHeading, Vector3 ang, Vector3 lAng, float sclFctr){
			
			//update the camera heading
			camHead = cHeading;
			bPoint = offset * camHead;
			
			Vector3 angle = ang;
			Vector3 lastAngle = lAng;
			
			for ( int i = 0; i < cubes.Count; i++ ) {
				//slowly rotate the cubes around their circle's basepoint
//				cubes[i].transform.RotateAround(bPoint, new Vector3(0.0f, 0.0f, 0.0f) - bPoint, rotation);
//				cubes[i].transform.LookAt(new Vector3(0,0,0));
//				cubes[i].transform.RotateAround( cubes[i].transform.position, cubes[i].transform.forward, 1.0f);
				cubes[i].transform.localScale = (new Vector3(sclFctr, sclFctr, sclFctr));
				cubes[i].transform.Rotate (angle-lastAngle);							
			}
		}
		
		public void display(Vector3 origin){
			//move the circle of cubes to the center of the camera's target
//			circle.transform.position = bPoint;
			//make the circle of cubes look at the origin
			circle.transform.LookAt (origin);
		}
		
	}

}
