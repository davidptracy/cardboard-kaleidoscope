// C# script for a 3D kaleidoscope.
// The script places a cube primitive on each vertex of a mesh and rotated in sync with a googleCardboard.
// In this case, the mesh is a procedurally generated icosahedron, see IcoSphereCreate.cs
// The script is attached to a gameObject which can be empty
// 2015 by David Tracy @ Rockwell Group Lab

using UnityEngine;
using System.Collections;
using System.Collections.Generic; // Generic is required to use Lists

public class sphericalOps : MonoBehaviour {

	//multiplier for the radius of the sphere
	public float mult;
	// a variable to reference the Cardboard camera, this is an event system with a script running called cardboardHandler.cs
	// cardboardHandler.cs pulls orientation values from the phone, once a frame or second, I can't remember
	public GameObject globalCardboardObject;
	// variables to hold the current and last rotations from Cardboard
	private Quaternion localCardboardRotation;
	private Quaternion lastLocalCardboardRotation;	
	// array to hold the vertices of the mesh
	private Vector3[] vertices;
	// array to hold the cubes generated by the mesh
	private List<GameObject> cubes;
	// an empty webcam texture
	private WebCamTexture mCamera = null;
	// a gameobject to reference the mesh
	private GameObject sphere;

	// Use this for initialization
	void Start () {

		// this is a hardcoded name generated by IcoSphereCreate.cs
		sphere = GameObject.Find("Isocahedron");

		// get the mesh component of the isocahedron
		Mesh mesh = sphere.GetComponent<MeshFilter> ().mesh;

		// an empty array to hold all of the vertices of the mesh
		vertices = mesh.vertices;

		// instantiate a new list of GameObjects
		cubes = new List<GameObject> ();

		// instantiate the webcam
		mCamera = new WebCamTexture ();

		// this is the distance multiplier, use this to space out the cubes 
		mult = 2.5f;

		// this will print out how many vertices the mesh has, and how many cubes are being drawn
		print (vertices.Length);

		// iterate through all the vertices to place a cube
		for (int i = 0; i<vertices.Length; i++) {
			// create the cube to place at the vertex
//			GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);

			// use this line below to load custom meshes from the 'Resources' folder
			GameObject cube = Instantiate(Resources.Load("hexDiamond")) as GameObject;


			// move the cube to the vertex
			cube.transform.position = new Vector3(vertices[i].x*mult, vertices[i].y*mult, vertices[i].z*mult);

			// rotate the cube so its looking at the origin, then rotate each one further
			cube.transform.LookAt(transform.position);
			cube.transform.Rotate(cube.transform.forward, 120*i, Space.World);

			// flips the texture of every other cube
//			if (i % 2 == 0){
//				cube.transform.localScale = new Vector3(-1.0f, -1.0f, 1.0f);
//			}

			// these are extra transforms 
//			cube.transform.Rotate (cube.transform.up, 90, Space.World);
//			cube.transform.Rotate(i*15, i*15, i*15);
//			cube.transform.localScale += new Vector3(-0.5f, -0.5f, -0.5f);
//			cube.transform.localScale += new Vector3( Random.Range(0.0f,2.0f), Random.Range(0.0f,2.0f), Random.Range(0.0f,2.0f));



			// set the cube's material to the webcam texture
			cube.GetComponent<Renderer>().material.mainTexture = mCamera;

			// set the shader for each cube
			Shader shader;
			Renderer rend;
			rend = cube.GetComponent<Renderer>();

			if (i % 3 == 0){
				shader = Shader.Find ("Custom/RedTint");
			}
			else if (i % 2 == 0){
				shader = Shader.Find ("Custom/GreenTint");
			} 
			else {
				shader = Shader.Find ("Custom/BlueTint");
			}

			shader = Shader.Find ("Custom/NormalTint");
			rend.material.shader = shader;

			// add the cube to the list of cubes
			cubes.Add (cube);

		}

		// play the camera
		mCamera.Play ();
	
	}
	
	// Update is called once per frame
	void Update () {

		float spRot = 0.0f;

		// rotate the icosahedron
		sphere.transform.Rotate (Vector3.up, spRot, Space.Self);

		spRot += 5.0f;

		// grabs cardboard rotation from the global game object
		localCardboardRotation = globalCardboardObject.GetComponent<CardboardHandler>().cardboardRotation;

		//convert cardboard rotation to useable euler angles
		var angles = localCardboardRotation.eulerAngles;
		var lastAngles = lastLocalCardboardRotation.eulerAngles;

		// iterate through all the cubes and rotate them based on head rotation from cardboard
		for (int i = 0; i<vertices.Length; i++) {

			// moves the cube to the updated vertex position
			cubes[i].transform.position = new Vector3(vertices[i].x*mult, vertices[i].y*mult, vertices[i].z*mult);

			// rotates cubes based on pure rotation of the headset
			cubes[i].transform.Rotate (angles-lastAngles);

			// rotates each cube independently of movement
//			cubes[i].transform.Rotate(cubes[i].transform.forward, 1.5f, Space.World);

			// rotates each cube along its forward facing vector (toward the camera) 
//			cubes[i].transform.Rotate(cubes[i].transform.forward, 2*Vector3.Magnitude(angles-lastAngles), Space.World);

			// rotates the cubes in different directions
			if (i % 2 == 0) {
				cubes[i].transform.Rotate(cubes[i].transform.forward, 1.25f, Space.World);
			} else {
				cubes[i].transform.Rotate(cubes[i].transform.forward, -1.25f, Space.World);
			}

//			if ( Vector3.Distance(cubes[i].transform.position, this.transform.position) >= mult ){
//
//				Vector3 gravity = cubes[i].transform.forward * 5.0f; 
//				Vector3 acceleration = cubes[i].transform.forward * (Vector3.Magnitude (angles - lastAngles));
//
//				cubes[i].transform.position += gravity;
//				cubes[i].transform.position += acceleration;
//			}

//			cubes[i].transform.localScale += (angles - lastAngles);		
		}

		// iterate through all the cubes and rotate them based on head rotation from cardboard
//		foreach (var cube in cubes) {

//			cube.transform.position = new Vector3(vertices[i].x*mult, vertices[i].y*mult, vertices[i].z*mult);

			// rotate the cubes relative to their last rotation
//			cube.transform.Rotate (angles-lastAngles);

//		}

//		mult = Mathf.Clamp (Vector3.Magnitude (angles - lastAngles) / 5, 2.5f, 10.0f);

		// set the current rotation equal to the last rotation so we can measure the difference in the next loop
		lastLocalCardboardRotation = localCardboardRotation;
	}
}