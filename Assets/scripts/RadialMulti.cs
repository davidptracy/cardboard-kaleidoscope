// C# script for a 3D kaleidoscope.
// This class generates a ring of cubes that rotate and orient themselves toward the camera.
// This script should be attached to an event system alongside CardboardHandler.cs
// 2015 by David Tracy @ Rockwell Group Lab

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class RadialMulti : MonoBehaviour {

	public GameObject cardboardHead; //a reference to the cardboard 'head'
	public GameObject globalCardboardObject; //a reference to the cardboardHandler script to get rotation values

	private Vector3 camHeading; //vector for rotation relative to camera
	private Vector3 camUp; //vector for rotation relative to camera
	private Vector3 origin;
	private Vector3 angles;
	private Vector3 lastAngles;

	private WebCamTexture mCamera = null; //an empty webcam texture

	private RadialKaleidoscope kaleidoscope1;
	private RadialKaleidoscope kaleidoscope2;
	private RadialKaleidoscope kaleidoscope3;

	private Quaternion localCardboardRotation; //variable to hold the current rotation from Cardboard
	private Quaternion lastLocalCardboardRotation; //variable to hold the last rotation from Cardboard

	private Shader shaderRed;
	private Shader shaderBlue;
	private Shader shaderGreen;
	
	// Use this for initialization
	void Start () {

		origin = new Vector3 (0.0f, 0.0f, 0.0f);

		mCamera = new WebCamTexture ();

		camHeading = cardboardHead.transform.forward;

		shaderRed = Shader.Find ("Custom/RedTint");
		shaderBlue = Shader.Find ("Custom/BlueTint");
		shaderGreen = Shader.Find ("Custom/GreenTint");

		// create the kaleidoscopes - constructor variables:
		// distance offset, cubeCount, radius, independent rotation, orientation vector, webcamTexture, scaleFactor, shader
		kaleidoscope1 = new RadialKaleidoscope (1.0f, 36, 1.25f, 0.25f, camHeading, mCamera, 1.0f, shaderGreen);
		kaleidoscope2 = new RadialKaleidoscope (2.0f, 24, 0.75f, 0.125f, camHeading, mCamera, 0.75f, shaderRed);
		kaleidoscope3 = new RadialKaleidoscope (3.0f, 16, 0.5f, 0.5f, camHeading, mCamera, 0.5f, shaderBlue);

		mCamera.Play ();

	}
	
	// Update is called once per frame
	void Update () {

		//update the camera heading
		camHeading = cardboardHead.transform.forward;

		//convert cardboard's quaternion to useable euler angles
		localCardboardRotation = this.GetComponent<CardboardHandler>().cardboardRotation;
		angles = localCardboardRotation.eulerAngles;
		lastAngles = lastLocalCardboardRotation.eulerAngles;
		
		kaleidoscope1.update (camHeading, angles, lastAngles);
		kaleidoscope1.display (origin);

		kaleidoscope2.update (camHeading, angles, lastAngles);
		kaleidoscope2.display (origin);

		kaleidoscope3.update (camHeading, angles, lastAngles);
		kaleidoscope3.display (origin);


		lastLocalCardboardRotation = localCardboardRotation;
	
	}

	private class RadialKaleidoscope {

		private Vector3 camHead; 
		private Vector3 bPoint; //basepoint for the circle origin
		private Vector3 angle;
		private Vector3 lastAngle;
		private int cubeCount; //the amount of cubes for the radial array
		private float radius; //the radius at which to place the cubes
		private float rotation; //the global rotation of the circle
		private float offset; //distance at which to orient the center of the circle
		private GameObject circle; //a parent gameObject to nest the cubes under, used for transformations
		private List<GameObject> cubes; //array to hold the cubes generated by the mesh
		
		//constructor
		public RadialKaleidoscope(float off, int cuCt, float r, float rot, Vector3 cHd, WebCamTexture mCam, float scl, Shader shdr ){

			offset = off;
			cubeCount = cuCt;
			radius = r;
			rotation = rot;

			bPoint = cHd*radius;	

			circle = new GameObject();
			circle.transform.position = bPoint;	

			//a list to hold all the cubes
			cubes = new List<GameObject> ();

			//create the cubes
			for (int i=0; i < cuCt; i++) {
				//generate a cube
				GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
				//move the cube to the basepoint
				cube.transform.position = bPoint;
				//scale the cubes
				cube.transform.localScale *= scl;
				//orient the cube toward the camera
				cube.transform.LookAt(new Vector3(0.0f, 0.0f, 0.0f));
				//move that cube to the side
				cube.transform.position = bPoint + cube.transform.right*radius;
				//rotate the cubes around the basePoint
				cube.transform.RotateAround(bPoint, bPoint - new Vector3(0.0f, 0.0f, 0.0f), i*360/cubeCount);
				//incremental rotation
				cube.transform.Rotate(cube.transform.forward, i*(360/cubeCount));
				//parent the cube to the empty circle object
				cube.transform.parent = circle.transform;
				//set the webcamTexture as the mainTexture for the cube
				cube.GetComponent<Renderer>().material.mainTexture = mCam;
				// instantiate a shader, pass it the Shader
				Shader shader = shdr;
				// instantiate a renderer
				Renderer rend;
				rend = cube.GetComponent<Renderer>();

				rend.material.shader = shader;
				//add the cube to the list
				cubes.Add(cube);
			}
		}

		public void update(Vector3 cHeading, Vector3 ang, Vector3 lAng){

			//update the camera heading
			camHead = cHeading;
			bPoint = offset * camHead;
			
			Vector3 angle = ang;
			Vector3 lastAngle = lAng;
			
			for ( int i = 0; i < cubes.Count; i++ ) {
				//slowly rotate the cubes around their circle's basepoint
				cubes[i].transform.RotateAround(bPoint, new Vector3(0.0f, 0.0f, 0.0f) - bPoint, rotation);
				cubes[i].transform.Rotate (angle-lastAngle);
				
			}
		}

		public void display(Vector3 origin){
			//move the circle of cubes to the center of the camera's target
			circle.transform.position = offset * camHead;
			//make the circle of cubes look at the origin
			circle.transform.LookAt (origin);
		}
		
	}
}
